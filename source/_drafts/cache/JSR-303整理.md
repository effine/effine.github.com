1.什么是JSR-303？它有什么作用？
JSR 303 – Bean Validation 是一个数据验证的规范，2009 年 11 月确定最终方案。2009 年 12 月 Java EE 6 发布，Bean Validation 作为一个重要特性被包含其中。
JSR 303 用于对Java Bean 中的字段的值进行验证。
2. Hibernate Validator
Hibernate Validator 是 Bean Validation 的参考实现 . Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。
2.1 如何使用Hibernate Validator
JSR-303的校验是基于注解的，它内部已经定义好了一系列的限制注解，我们只需要把这些注解标记在需要验证的实体类的属性上或是其对应的get方法上，还可以标记在方法的参数和返回值。
约束分为：
字段级约束
属性级约束
类级约束(不是所有的约束都能够被用在所有的类结构上. 事实上, 没有任何定义在Bean Validation规范中的约束可以被用在class上.)
例：
public class Product{

    //1.标记在对象的属性上：
    @Size(min = 10, max=10) //字符串长度为10
    @NotBlank   //字符串不能为空
    private String id;
    
    @Min(0) //最小值为0
    private int price;
    
    private String productName;
    
    @NotNull    
    public String getProductName() {
        return productName;
    }
}


//为了使在方法参数上的约束生效，还需在方法所在类上添加@Validated注解
@Validated
public class Math{
   //标注在方法的返回值和方法的参数上
    public @Min(10) int sum( @Min(0) int x,@Max(100) int y){
        retunr x+y;
    }
}
2.1.1 若对象继承是否会继承父类的约束？
会。若父类的属性或字段上有约束注解，在使用子类时，也会对父类的属性或字段进行校验。
//父类
@PassengerCount 
public class Car {

    @NotNull(message="我可不是没有制造商的车，别忘了我的制造商！") //通过给message属性赋值，可以自定义错误消息提示
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;

    ...
}

//子类: 若是校验了一个 RentalCar 的实例对象，父类中 @Size(min = 10, max=10)约束仍然生效
public class RentalCar extends Car {

    @NotNull
    private String rentalStation;
    
    ...
}
2.1.2 若是对象中引用了另一对象如何校验对象中的引用呢？
可以使用@Valid 注解来使引用对象中的约束生效。
public class Person {

    @NotNull
    private String name;
}

public class Car {

    @NotNull
    @Valid  //添上这个注解后，在校验car的实例的同时也会校验Pesron中的@NotNull 约束。
    private Person driver;
}
2.2 JSR-303实现的约束以及Hibernate Validate额外实现的约束
空校验：
校验注解	注解功能
@Null	验证对象是否为null。
@NotNull	验证对象是否不为null, 无法查检长度为0的字符串。
@NotBlank	检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串有效,且会去掉前后空格。
@NotEmpty	检查约束元素是否为NULL或者是EMPTY。
Boolean 校验：
校验注解	注解功能
@AssertTrue	验证 Boolean 对象是否为 true。
@AssertFalse	验证 Boolean 对象是否为 false。
长度校验：
校验注解	注解功能
@Size(min, max)	验证对象（Array,Collection,Map,String）长度是否在给定的范围之内。
@Length(min, max)	验证字符串对象长度在 min 和 max之间。Min 默认为0。若被标注的值为null也能通过验证。
日期校验：
校验注解	注解功能
@Past	验证 Date 和 Calendar 对象是否在当前时间之前(使用joda time)。
@Future	验证 Date 和 Calendar 对象是否在当前时间之后(使用joda time)。
正则校验：
校验注解	注解功能
@Pattern(regexp)	验证 String 对象是否符合正则表达式的规则。
数值校验：
校验注解	注解功能
@Min	验证 Number 和 String 对象是否大等于指定的值。
@Max	验证 Number 和 String 对象是否小等于指定的值 。
@DecimalMax	被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示,小数存在精度。
@DecimalMin	被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示,小数存在精度。
@Digits(integer,fraction)	验证字符串是否是符合指定格式的数字，interger指定 整数精度，fraction指定小数精度。
@Range(min, max)	验证被标注的值是否在指定范围之间。
邮箱校验：
校验注解	注解功能
@Email	验证是否是邮件地址，如果为null,不进行验证，算通过验证。
HTML校验：
校验注解	注解功能
@SafeHtml(whitelistType,additionalTags)	验证被标注的值是否存在恶意的标签，如script 标签，whitelistTyep 定义白名单，additionalTags 为whitelistTyep 添加额外的白名单标签。
URL校验：
校验注解	注解功能
@URL(protocol,host,port,regexp,flags)	验证被标注的值，依据RFC2396判定是否为一个有效的URL。Regexp和flags可以为被标注的值添加额外的URL验证规则。还能自己指定特定的protocol，host，port。
2.3 自定义约束
2.3.1 自定义注解：
@Target( { METHOD, FIELD, ANNOTATION_TYPE })    //指定注解使用范围:此处为 方法，字段或者注解上
@Retention(RUNTIME)     //表示这个标注信息是在运行期通过反射被读取的
@Constraint(validatedBy = CheckCaseValidator.class) //指明使用那个校验器去校验使用了此标注的元素.
@Documented     //表示在对使用了@CheckCase的类进行javadoc操作到时候, 这个标注会被添加到javadoc当中.
public @interface CheckCase {
    
    //message属性, 这个属性被用来定义默认得消息模版, 当这个约束条件被验证失败的时候,通过此属性来输出错误信息.
    String message() default "{com.mycompany.constraints.checkcase}";

    //groups 属性, 用于指定这个约束条件属于哪(些)个校验组. 这个的默认值必须是Class<?>类型到空到数组.
    Class<?>[] groups() default {};

    //payload 属性, Bean Validation API 的使用者可以通过此属性来给约束条件指定严重级别. 这个属性并不被API自身所使用
    Class<? extends Payload>[] payload() default {};

    CaseMode value();

}
2.3.2 自定义校验器：
public class CheckCaseValidator implements ConstraintValidator<CheckCase, String> {

/** ConstraintValidator定义了两个泛型参数, 第一个是这个校验器所服务到标注类型(在我们的例子中即CheckCase), * 第二个这个校验器所支持到被校验元素到类型 * (即String)；如果一个约束标注支持多种类型到被校验元素的话, 那么需要为每个所支持的类型定义一个ConstraintValidator,并且注册到约束标注中. */

    //初始化方法
    public void initialize(CheckCase constraintAnnotation) {
        this.caseMode = constraintAnnotation.value();
    }

    //此方法才是真正校验的逻辑实现方法
    public boolean isValid(String object, ConstraintValidatorContext constraintContext) {

        if (object == null)             return true;

        if (caseMode == CaseMode.UPPER)
            return object.equals(object.toUpperCase());
        else
            return object.equals(object.toLowerCase());
    }

}
2.3.3 校验错误信息：
最后, 我们还需要指定如果@CheckCase这个约束条件验证的时候,没有通过的话的校验错误信息. 我们可以添加下面的内容到我们项目自定义的ValidationMessages.properties
com.mycompany.constraints.CheckCase.message = Case mode must be {value}.
maven :
<dependency>
    <groupId>org.hibernate</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>5.2.4.Final</version>
</dependency>
Spring :
<mvc:annotation-driven validator="validator" />

<!-- 注入ValidatorFactoryBean -->
<bean id="validator" class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean">
	<property name="providerClass" value="org.hibernate.validator.HibernateValidator" />
	<!-- 如果不加默认到 使用classpath下的 ValidationMessages.properties -->
	<property name="validationMessageSource" ref="messageSource" />
</bean>

 <!-- 使Spring支持方法上使用JSR-303约束注解 -->
<bean class="org.springframework.validation.beanvalidation.MethodValidationPostProcessor" />

<!-- 国际化的消息资源文件（本系统中主要用于显示/错误消息定制） -->
<bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
	<property name="basenames">
		<list>
			<!-- 在web环境中一定要定位到classpath 否则默认到当前web应用下找 -->
			<value>classpath:ValidationMessages</value>
		</list>
	</property>
	<property name="useCodeAsDefaultMessage" value="true" />
	<property name="defaultEncoding" value="UTF-8" />
	<property name="cacheSeconds" value="60" />
</bean>