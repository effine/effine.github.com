---
title: Java反编译
date: 2012-10-14 23:33:21
categories: Java
tags: [java,编译]
---
1. 安装软件：DJ Java Decompiler 3.7 （网上有自己下载）
2. 安装完软件，可以进行可视化的 java  反编译（*.Class --> *.java），也可以使用命令（cmd）

可视化反编译：自己打开软件，尝试使用就行了

命令行反编译：将  DJ Java Decompiler 3.7的安装目录 加入到环境变量 Path中。（我安装在E:\ReverseCompile，该目录下有个DJ.exe，所以把该目录加入到环境变量Path中就完事）

3. 进行反编译即可：我使用的命令： jad -o -r -d F:\src  -s java F:\bin\**\*.class （F:\src 目标目录，F:\bin 需要反编译的文件夹 ）
-o  - overwrite output files without confirmation (default: no) 无需确定覆写文件
-r  - restore package directory structrure 恢复包目录结构
-s <ext></ext>- output file extension (by default '.jad') 如果不设置为-s java，则默认扩展名为.jad
其他的，F:\bin\**\*.class 中的两颗接连的星，表示任意层次的子目录。

-a -用JVM字节格式来注解输出 
-af - 同-a,但是注解的时候用全名称 
-clear - 清除所有的前缀 
-b - 输出多于的括号 (e.g., if(a) { b(); }, default: no) 
-d <dir> - 指定输出文件的文件目录
-dead -试图反编译代码的dead 部分(default: no) 
-disass - 不用用字节码的方式反编译 (no JAVA source generated) 
-f - 输出整个的名字,无论是类还是方法 
-ff -输出类的成员在方法之前 (default: after methods) 
-i - 输出所有的变量的缺省的最初值 
-l<num> - 将strings分割成指定数目的块的字符 (default: no) 
-lnc - 将输出文件用行号来注解 (default: no) 
-nl - 分割strings用新行字符 newline character (default: no) 
-nodos -不要去检查class文件是否以dos方式写 (CRbefore NL, default: check) 
-nocast - 不要生成辅助文件 
-nocode -不要生成方法的源代码 
-noconv - 不要转换java的定义符 (default: do) 
-noctor - 不允许空的构造器存在 
-noinner -关掉对内部类的支持 (default: turn on) 
-nolvt - 忽略局部变量的表信息 
-nonlb - 不要输出一个新行在打开一个括号之前 (default: do) 
-o - 无需确认直接覆盖输出 (default: no) 
-p - 发送反编译代码到标准输出 STDOUT (e.g., for piping) 

其次.常用命令
jad-o -r -sjava -dsrc test.class
tree目录下的所有*.class文件
    jad -o -r -sjava-dsrc tree/**/*.class
unix可以表示为：jad -o -r -sjava -dsrc 'tree/**/*.class'
指定输出文件的名字的话，用以下的转移命令
jad -p example1.class > myexm1.java
 
体会：反编译后，所有变量的声明都放在类的结尾处，添加一个显示的构造方法，变量的初始化都在构造方法中完成；java文件中的中文将全部转换成ASCII码！System.out.println()中输出的String字符串，将使用new StringBuffer（）替换，字符串连接符“+”将使用append()替换。暂时使用中知道这些
 
刚刚发现个更好的java反编译工具：Java Decompiler （官网：http://java.decompiler.free.fr/），该工具有JD-GUIJD-EclipseJD-IntelliJ 模式，我用的是JD-GUI 不错反编译工具